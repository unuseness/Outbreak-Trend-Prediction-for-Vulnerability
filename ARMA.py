# -*- coding: UTF-8 -*-
# @Time : 2022/9/21 16:01
# @File : ARMA.py

"""
    current model： forecast imf components and residual
"""

import pandas as pd
import numpy as np
from statsmodels.tsa.stattools import adfuller
import statsmodels.tsa.api as smtsa
from statsmodels.graphics.tsaplots import plot_acf,plot_pacf
from statsmodels.tsa.seasonal import seasonal_decompose
import matplotlib.pyplot as plt
from scipy import signal

from Checkout import checkout_smooth, checkout_wnoise
from OrderArma import order
from createCsv import createCsv

def imf_arma(imf, diff, p, q, path):
# def imf_arma(imf, diff, p, q):
# def imf_arma(imf):
    """
    performs arma on provided imf
    imf0: smooth (2,4)--> (0,9)
    imf1: smooth (4,3) or (4,2)
    imf2: smooth (4,5)
    imf3: smooth (1,0)
    imf4: diff(1,2) execute 2 times diif(1) (2,2)
    imf5: log(imf5) (2,0)
    imf6: smooth (1,0)
    imf0 + imf1: smooth (5,9)

    ----------
    Parameters:
    diff: smooth method
          1--> signal is stationary
          2--> signal execute diff(1,2)
          3--> signal execute log
    (p, q): ARMA order(p,q)
    ----------

    """
    # 将imf调整为基于Numpy的ndarray 结构的一位数组，其有索引index
    imfArr = pd.Series(imf, index=pd.date_range(start="2001-01-01", end="2021-12-01", freq="BMS"))
    # createCsv(imfArr, path)
    imfRaw = imfArr
    # check stationariness

    # imf4
    if diff == 2:
        imfArr = imfArr.diff(1).diff(1).dropna(how=any)
    # imf5
    if diff == 3:
        imfArr = np.log(imfArr).dropna(how=any)
    if diff == 1:
        imfArr = imfArr.diff(1).dropna(how=any)

    checkout_smooth(imfArr)
    checkout_wnoise(imfArr)

    num_peaks = signal.find_peaks(imfArr)
    print(len(num_peaks[0]))


    # min_ari, min_maj = order(imfArr)
    # print(min_ari,min_maj)


    plot_pacf(imfArr, method='ywm') # AR(p),确定AR阶数看pacf p
    plot_acf(imfArr) # MA(q),确定MA阶数看acf q
    plt.show()

    try:
        model = smtsa.ARMA(imfArr[:-12], order=(p, q))
        # model = smtsa.ARMA(imfArr[:-12], order=(min_ari,min_maj))
        # arma_obj_fin = model.fit(start_ar_lags=30, method='css', trend='nc', disp=-1)
        arma_obj_fin = model.fit(start_ar_lags=16, disp=-1)
    except Exception as e:
        print(e)
    # arma_obj_fin.summary()
    # imf_predict = arma_obj_fin.predict(end="2021-3-1")
    #
    #
    # try:
    #     model = smtsa.ARMA(imf_predict, order=(p, q))
    #     # model = smtsa.ARMA(imfArr[:-12], order=(min_ari,min_maj))
    #     # arma_obj_fin = model.fit(start_ar_lags=30, method='css', trend='nc', disp=-1)
    #     arma_obj_fin = model.fit(start_ar_lags=16, disp=-1)
    # except Exception as e:
    #     print(e)
    # arma_obj_fin.summary()
    # imf_predict = arma_obj_fin.predict(end="2021-6-1")
    #
    #
    # try:
    #     model = smtsa.ARMA(imf_predict, order=(p, q))
    #     # model = smtsa.ARMA(imfArr[:-12], order=(min_ari,min_maj))
    #     # arma_obj_fin = model.fit(start_ar_lags=30, method='css', trend='nc', disp=-1)
    #     arma_obj_fin = model.fit(start_ar_lags=16, disp=-1)
    # except Exception as e:
    #     print(e)
    # arma_obj_fin.summary()
    # imf_predict = arma_obj_fin.predict(end="2021-9-1")
    #
    # try:
    #     model = smtsa.ARMA(imf_predict, order=(p, q))
    #     # model = smtsa.ARMA(imfArr[:-12], order=(min_ari,min_maj))
    #     # arma_obj_fin = model.fit(start_ar_lags=30, method='css', trend='nc', disp=-1)
    #     arma_obj_fin = model.fit(start_ar_lags=16, disp=-1)
    # except Exception as e:
    #     print(e)
    arma_obj_fin.summary()
    imf_predict = arma_obj_fin.predict(end="2021-12-1")


    if diff == 1:
        raw_diff_shift = imfRaw.shift(1)
        imf_predict = imf_predict.add(raw_diff_shift)

    if diff == 2:
        raw_diff_shift = imfRaw.diff(1).shift(1)
        predict_recover_1 = imf_predict.add(raw_diff_shift)
        raw_shift = imfRaw.shift(1)
        imf_predict = predict_recover_1.add(raw_shift)
    if diff == 3:
        imf_predict = np.exp(imf_predict)

    # store data
    # createCsv(imf_predict.dropna(how=any), "result_"+path)

    plt.figure(figsize=(10, 8))
    plt.plot(imfRaw.iloc[-100:], color='b', label='Actual')
    plt.plot(imf_predict.iloc[-100:], color='r', linestyle='--', label='ARMA_best_pre')
    plt.xlabel('date')
    plt.ylabel('vulnerable numbers')
    plt.legend(loc='best')

    plt.show()

    return imf_predict


def residual_arma(rs, p, q, path):
    # 将数据转化为pd.Series形式
    rsArr = pd.Series(rs, index=pd.date_range(start="2001-01-01", end="2021-12-01", freq="BMS"))
    # createCsv(rsArr, path)

    # 验证原始数据的残差对数据造成的影响，（小）
    trend, seasonal, residual = decompose(rsArr)

    # 时序数据预测
    """ 该序列具有明显的年周期与长期成分。对于年周期成分我们使用窗口为12的移动平进行处理，
        对于长期趋势成分我们采用1阶差分来进行处理。
        据观察，该数据在置信度为99%的区间下显著。    
    """
    rs_rol_mean = rsArr.rolling(window=12).mean()  # 12阶移动平均
    rs_rol_mean.dropna(inplace=True)
    # print(rol_mean)

    # rs_rol_mean.diff(1).diff(1).dropna(how=any)
    checkout_smooth(rs_rol_mean)
    checkout_wnoise(rs_rol_mean)

    # 绘画出 acf 以及 pacf
    # plot_pacf(rs_rol_mean, method='ywm')  # AR(p),确定AR阶数看pacf p
    # plot_acf(rs_rol_mean)  # MA(q),确定MA阶数看acf q

    # 使用 ARMA 模型进行拟合
    # min_ari, min_maj = order(rs_rol_mean)
    # print(min_ari, min_maj)

    try:
        model = smtsa.ARMA(rs_rol_mean[:-12], order=(p, q))
        result_arima = model.fit(start_ar_lags=30, method='css', trend='nc', disp=-1)
    except Exception as e:
        print(e)
    # 预测 predict 索引 2 对应的开始时间为 2002-4 其长度为240
    # predict_ts = result_arima.predict(end="2021-3-1")
    #
    # try:
    #     model = smtsa.ARMA(predict_ts, order=(p, q))
    #     result_arima = model.fit(start_ar_lags=30, method='css', trend='nc', disp=-1)
    # except Exception as e:
    #     print(e)
    # # 预测 predict 索引 2 对应的开始时间为 2002-4 其长度为240
    # predict_ts = result_arima.predict(end="2021-6-1")
    #
    # try:
    #     model = smtsa.ARMA(predict_ts, order=(p, q))
    #     result_arima = model.fit(start_ar_lags=30, method='css', trend='nc', disp=-1)
    # except Exception as e:
    #     print(e)
    # # 预测 predict 索引 2 对应的开始时间为 2002-4 其长度为240
    # predict_ts = result_arima.predict(end="2021-9-1")
    #
    # try:
    #     model = smtsa.ARMA(predict_ts, order=(p, q))
    #     result_arima = model.fit(start_ar_lags=30, method='css', trend='nc', disp=-1)
    # except Exception as e:
    #     print(e)
    # 预测 predict 索引 2 对应的开始时间为 2002-4 其长度为240
    predict_ts = result_arima.predict(end="2021-12-1")


    # 移动平均还原
    rol_sum = rsArr.rolling(window=11).sum().dropna(how=any)
    rol_recover = predict_ts * 12 - rol_sum.shift(1)

    # createCsv(rol_recover.dropna(how=any), "result_" + path)

    ts = rsArr[rol_recover.index]  # 过滤没有预测的记录plt.figure(facecolor='white')
    plt.figure(figsize=(10, 8))
    rol_recover[:].plot(color='blue', label='Predict')
    ts[:].plot(color='red', label='Original')
    plt.legend(loc='best')
    plt.title('RMSE: %.4f' % np.sqrt(sum((rol_recover - ts) ** 2) / ts.size))
    plt.show()

    return rol_recover[:]


def decompose(timeseries):
    # 返回包含三个部分 trend（趋势部分） ， seasonal（季节性部分） 和residual (残留部分)
    decomposition = seasonal_decompose(timeseries,period = 12)

    trend = decomposition.trend
    seasonal = decomposition.seasonal
    residual = decomposition.resid

    # createCsv(trend.dropna(how=any),'trend.csv')
    # createCsv(seasonal.dropna(how=any), 'seasonal.csv')
    # createCsv(residual.dropna(how=any), 'residual.csv')
    # print(trend)
    plt.subplot(411)
    plt.plot(timeseries, label='Original')
    plt.legend(loc='best')
    plt.subplot(412)
    plt.plot(trend, label='Trend')
    plt.legend(loc='best')
    plt.subplot(413)
    plt.plot(seasonal, label='Seasonality')
    plt.legend(loc='best')
    plt.subplot(414)
    plt.plot(residual, label='Residuals')
    plt.legend(loc='best')
    plt.tight_layout()
    plt.show()
    return trend, seasonal, residual